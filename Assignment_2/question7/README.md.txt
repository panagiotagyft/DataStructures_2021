Παναγιώτα Γύφτου Α.Μ.:1115201900318

Θα ήθελα να επισημάνω οτι σαν πρώτο όρισμα θα ήταν καλό να δώσετε πάνω από 4 γιατί στην STdelete δίνω σαν όρισμα το 4o μικρότερο στοιχείο που δίνει η STselect γι'αυτόν 
τον λόγο θα βγάλει ένα λογικό segmentation fault (το γράφω και πιο κάτω). Αρχικά θέλω να σας ενημερώσω ότι για κάθε άσκηση έχω φτιάξει έναν ξεχωριστό φάκελο.Σας ζητάω 
συγγνώμη αν είναι κακή η οργάνωση της άσκησης μου.Για κάθε άσκηση μέσα στον φάκελο εκτός από τις συναρτήσεις έχω φτιάξει και makefile.Όλα τα προγράμματα τρέχουν με 
ανακατεύθυνση,στην οποία το πρώτο όρισμα δίνουμε τον αριθμό των στοιχείων που θέλουμε να εισάγουμε και στο δευτερο αν είναι 0 ο χρήστης δίνει τα στοιχεία αλλιώς 
(αν διαφορετικό του 0) γεννιούνται τυχαία στοιχεία, σε αυτό το σημείο θα ήθελα να ΕΠΙΣΗΜΑΝΩ οτι σαν πρώτο όρισμα θα ήταν καλό να δώσετε πάνω από 4 γιατί στην STdelete 
δίνω σαν όρισμα το 4o μικρότερο στοιχείο που δίνει η STselect γι'αυτόν τον λόγο θα βγάλει ένα λογικό segmentation fault.Τέλος έχω δημιουργήσει και μια συνάρτηση όπου 
εκτυπώνει το δέντρο όπως ακριβώς είναι στην πραγματικότητα με τις θέσεις που βρίσκονται οι κόμβοι αλλά και με τις τιμές τους και με την πληροφορία Ν που είναι 
αποθηκευμένη στον κόμβο. Για την 7.3 εκτυπώνω και τα στοιχεία του φοιτητή δηλαδή το ονοματεπωνυμο.

Στην 7.1 οργάνωσα τον κώδικα όπως ζητείται, δημιουργώντας τρία .c αρχεία και 2 .h.Για να πετύχω το information hiding έβαλα την δομή στο bst-implementation αρχείο, ώστε 
να μην είναι ορατή από τον χρήστη.Για την διόρθωση των πεδίων καταμέτρησης των κόμβων ( Ν ) έχω φτιάξει μια βοηθητική συνάρτηση (την Fix_N), η οποία διασχίζει όλα το 
δέντρο από πάνω προς τα κάτω και ενημερώνει τον κάθε κόμβο.Αυτή την συνάρτηση την έχω τοποθετήσει στην STinsert και στην STdelete, ώστε κάθε φορά που εισάγω ή διαγράφω 
κάποιον κόμβο να ενημερώνονται όλοι οι κόμβοι του δέντρου.Στο demo.c στην main έχω βάλει σε σχόλιο την STinsert1 η οποία λειτουργεί και αυτή κανονικά.


Στην 7.2 η επέκταση που έκανα είναι να καλώ την STdeleteAll, η οποία καλεί την deleteR για να διαγράψει το στοιχείο.Όταν τελειώσει φτιάχνει τα Ν με την Fix_N.Επειτα 
ελέγχω εαν υπάρχει το ίδιο στοιχείο στο δέντρο, αν ναι καλώ αναδρομικά την SdeleteAll για να το σβήσει.Τέλος και εδώ έχω σε σχολιο την μια απο τις δύο συναντήσεις 
εισαγωγής.


Στην 7.3 όπως και στις άλλες δύο ασκήσεις βάζω σε σχόλιο την μια απο τις δύο συναρτήσεις εισαγωγής.Ο χρήστης με ανακατεύθυνση επιλέγει πάλι τον αριθμό των στοιχείων που
θα εκχωρηθούν.Αρχικά ο χρήστης καλείται να πληκτρολογήσει έναν ακέραιο αριθμό που είναι ο αριθμός μητρώου του φοιτητή.Έπειτα το όνομα και το επώνυμο του φοιτητή.Η 
επέκταση που έχω κάνει είναι να επεκτείνω την δομή , η οποία να μπορεί να αποθηκεύει το όνομα και το επώνυμο του φοιτητή.Στην STinit αρχικοποιώ το κενό δέντρο με 
αριθμό -1 με συνδέσμους που δείχνουν NULL και τις 2 συμβολοσειρές με “-” (παύλα).Όταν δημιουργώ νέο κόμβο για την εισαγωγή νέου στοιχείου, δεσμεύω χώρο για τις 
συμβολοσειρές ώστε να μπορέσουν να αντιγραφούν οι συμβολοσειρές που πληκτρολόγησε ο χρήστης.


Στην 7.4 φτιάχνω 3 δέντρα ίδιου τύπου.Εννοείται πως ο χρήστης μπορεί να δημιουργεί όσα θέλει.Για να το πετύχω αυτό και να κάνω σωστό information hiding στην main έχω 
ορίσει τρεις μεταβλητές t1,t2,t3 τύπου Tree.Tree είναι ένα typedef μιας δομής το οποίο βρίσκεται στο ST.h.Η δομή αυτή που βρίσκεται στο bst-implementation.c αρχείο 
περιέχει την head δηλαδή τη ρίζα και τον dummy κόμβο z.Αρχικά πρέπει να αχικoποιήσω το t1,t2,t3 και αυτο το επιτυγχάνω μέσω της STinit.Αυτό που κάνει η STinit είναι να 
εσμεύει χώρο ώστε η μεταβλητή να δείχνει κάπου συγκεκριμένα και να αρχιποιεί το dummy κόμβο z.Όλες οι συναρτήσεις έχουν τροποποιηθεί κατάλληλα, ώστε να ενημερώνεται το 
t και να επιστρέφεται όταν τροποποιείται, στον χρήστη ενημερομένο.