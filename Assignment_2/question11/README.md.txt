Παναγιώτα Γύφτου Α.Μ. 1115201900318

Έχω φτιάξει Makefile δεν κάνω ανακατεύθυνση.Στο implementation αρχείο εκτός απο τις διάφορες υλοποιήσεις συναρτήσεων έχω και την δομή των κόμβων του δέντρου (2,4) ώστε 
να κάνω information hiding.Συγκεκριμένα η δομή περιέχει: χώρο για 4 ακεραίους, έναν μετρητή Counter, με τον οποίο μετράω τις θέσεις που έχουν δεσμευθεί στον κόμβο.Αλλά 
και 4 θέσιες για συνδέσμους , όπου δείχνουν τα παιδιά του κόμβου.Η πρώτη υλοποίηση συνάρτησης είναι η STcount όπου δίνει στον χρήστη τον αριθμό των κόμβων που έχουν 
δημιουργηθεί επιστρέφοντας το Ν της ρίζας.Στην συνέχεια με 4 συναρτήσεις υλοποιώ την διαδικασία εισαγωγής στοιχείων στο δέντρο (2,4).Αρχικά με την STinsert, η οποία 
δουλειά της είναι να καλέι την συνάρτηση find_pos, όπου επιστρέφει αν πρέπει η STinsert να δημιουργήσει κόμβο ρίζας.Αν επιστρέψει Bool -> True τότε με την create 
δημιουργεί έναν κόμβο που είναι ρίζα, τοποθετώντας την τιμή που πρέπει.Στο παράδειγμα που έχω δώσει όπου είναι απο τις διαφάνειες των διαλέξεων η create χρησιμοποιείται 
3 φορές , αρχικά για την δημιουργία του δέντρου αφού είναι κενό, έπειτα όταν είμαστε στην περίπτωση 4,6,12,15 όπου φτιάχνουμε νέα ρίζα (12) και κάνουμε split.
Τέλος όταν τελειώνουμε φτιάχνουμε το Ν τον αριθμό των κόμβων , με την Fix_Ν.Η Fix_Ν αυτό που κάνει είναι να διασχίζει αναδρομικά όλο το δέντρο, απο πάνω προς τα κάτω, 
αν ο επόμενος κόμβος είναι NULL το Ν του τρέχοντος είναι 1 και επιστρέφει 1.Έτσι κάθε φορά αυτό που γυρίζει προστίθεται στους κόμβους που τον κάλεσαν. Επιστρέφω στην 
find_pos.Η find_pos διασχίζει όλο το δέντρο αναδρομικά μέχρι να βρεί την κατάλληλη θεση για το στοιχείο που πρέπει να εισαχθεί ,αν το δέντρο είναι κενό επιστρέφω Bool 
True.Αν το στοιχείο είναι μεγαλύτερο ή ίσο απο το 1ο στοιχείο του τρέχοντος κόμβου ψάχνω την θέση, αν υπάρχει το στοιχείο επιστρέφω False.Αν δεν είναι μεγαλύτερο του 1 
λέω οτι η θέση είναι η 0.Αναδρομικά διασχίζω όλο το δέντρο από πάνω προς τα κατω , αν αυτό που επιστρέφουν οι ανδρομικές κλήσεις είναι True τότε έχω δύο επιλογές ή 
κάνω προσθήκη της τιμής ή αν γίνεται overflow κάνω split . Η συνάρτηση όπου υλοποιεί την προσθήκη είναι η insert_item με την βοήθεια της θέσης που έχουμε βρεί οπου 
πρέπει να εισαχθεί το στοιχείο αλλα και με τον κόμβο στον οποίο θα εισαχθεί αυτό που κάνω ειναι να σπρώξω τα στοιχεία που πρέπει, να κάνω χώρο και να βάλω την τιμή στην 
θέση που πρέπει και να αυξήσω το Counter.Η συνάρτηση split.Αρχικά στην split βρίσκω που πρέπει να γίνει η διάσπαση του κόμβου ,έπειτα μετακινώ τα στοιχεία που πρέπει 
να μπουν στον νέο δεξί κόμβο που δημιούργησα.Φτιάχνω τον counter και τέλος να τοποθετήσω το πρέπει στον πατέρα.Στην συνέχεια έχω την συνάρτηση STinsert , όπου βρίσκει 
αν υπάρχει ένα στοιχειο με την βοήθεια της search ,η οποία διασχίζει το δέντρο από πάνω προς τα κάτω μέχρι να βρει αν υπάρχει το στοιχείο.Ακολουθούν οι συναρτήσεις 
εκτύπωσης έχω την STprint ,η οποία καλεί την print και την inorder . Με την print εκτυπώνω κάθε κόμβο του δέντρου με την τιμή που περιέχει το counter, και το αριθμό των 
κόμβων.Με την inorder εκτυπώνω με φυσική διάταξη την ακολουθία των τιμών.Έπειτα έχουμε τις συναρτήσεις εύρεσης του k-οστού μικρότερου κλειδιού.Η select διασχίζει το 
δέντρο με την φυσική διάταξη των στοιχείων ώστε να βρεθεί το k-οστό μικρότερο κλειδί.Αυτό γίνεται από την selectR η οποία κλήθηκε από την STselect έχοντας την βοήθεια 
δύων εξωτερικών μεταβλητών.Την μεταβλητή χ όπου λειτουργεί ως counter και την f όπου αποθηκεύω την τιμή και την επιστρέφω στον χρήστη.Έπειτα υλοποιώ μέσα από διάφορες 
συναρτήσεις την διαγραφή ενός στοιχείου από το δέντρο.Ξεκινάω με την STdelete όπου είναι η γέφυρα με τον εξωτερικό κόσμο του χρήστη.Η STdelete καλίτην deleteR η οποία 
καλεί την RemoveFromTheNode, που ψάχνει που είναι το στοιχείο που θέλει να διαγράψει.Αν βρισκόμαστε σε φύλλο απλώς διαγράφουμε το στοιχείο αν με την βοήθεια της 
Remove_value και έπειτα μέσω της Store ή θα κάνουμε transfer αν υπάρχει άμεσος αδερφός κόμβος με τις left και right.Αν είμαστε σε ρίζα ή σε ενδιάμεσο κόμβο έχουμε πχ 
διαγράφουμε τη ρίζα αντικαθιστουμε την ρίζα με τον προκάτοχό της.Αυτή η διαδικασία γίνεται μέσω της Copy.Έπειτα μέσω της fusionNodes κανουμε συνένωση των κόμβων ώστε 
να επιδιορθώσουμε τους συνδέσμους αλλά και την αύξουσα σειρά των στοιχειών μετα την τοποθέτηση του στοιχείου στην ρίζα πχ.Η ίδια διαδικασία ισχύει και για ενδιάμεσους 
κόμβους.