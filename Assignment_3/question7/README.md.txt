# Question7
Παναγιώτα Γύφτου Α.Μ. 1115201900318

Στην άσκηση 7 διαβάζω το αρχείο txt χρησιμοποιώντας fscanf και εκτελώ πχ **./main vertex1.txt**

**Η αρίθμηση των κορυφών μου ξεκινάει απο το 0**.Σας έχω δύο αρχεία txt το vertex1.txt είναι ο συνεκτικός γράφος των διαλέξεων της διαφάνειας 93 αλλά των έχω μετατρέψει 
σε μη κατευθυνόμνεο (γιατί αυτός των διαφανειών είναι κατευθυνόμενος) και το δεύτερο vertex2.txt είναι ένας μη συνεκτικός γράφος 2 υπογράφων.


1.Η συνάρτηση *undirected*: με αυτή την συνάρτηση δεσμεύω χώρο στην μνήμη,ώστε να αποθηκεύσω τον γράφο που δημιουργώ.


2. Η συνάρτηση *Initialize*: στην συνάρτηση αυτή παίρνω σαν όρισμα έναν γράφο μη αρχικοποιημένο και έναν ακέραιο αριθμό n που είναι ο αριθμός των κορυφών.Η λειτουργία 
της είναι να αρχικοποιεί τον γράφο μεγέθους n.Επειδή η υλοποίηση του γράφου είναι με λίστες γειτνίασης κάθε θέση του πίνακα firstedge περιέχει μια κορυφή που δείχνει 
στα endpoint του ,δηλαδή με ποιές κορυφές ενώνονται.Αρχικά κάθε θέση του πίνακα firstedge,τις αρχικοποιούμε να δείχνουν στο NULL .Στο τέλος η συνάρτηση επιστρέφει στον 
χρήστη έναν κενό αρχικοποιημένο γράφο.


3.Η *InsertEdge*: η συνάρτηση αυτή έχει ως ορίσματα τον γράφο και μια ακμή (int x, int y).Στην υλοποίηση μου επέλεξα τα endpoint τα αποθηκεύω σε αύξουσα σειρά, κάνω 
insert στο τέλος της λίστας και στο αρχείο txt (όπως σε αυτά που έχω ανεβάσει vertex1.txt και vertex2.txt ) γράφω με αύξουσα σειρά τις ακμές ,για να επιτευχθεί η 
αποθήκευση των στοιχείων με φυσική σειρά.Επειδή ο γράφος είναι μη κατευθυνόμενος αποθηκεύω μαζί με την (x,y) ακμή και την (y,x) (πάλι κάνω προσθήση του στοιχείου στο 
τέλος της λίστας).Έτσι με αυτόν τον τρόπο αποθηκεύω ταυτόχρονα τις δύο αντίθετες κορυφές.


4.Η συνάρτηση *ShowGraph*: εκτυπώνει την αναπαράσταση της λίστα γειτνίασης,δηλαδή όλες τις κορυφές με τα endpoint τους.


5.Η *BreathFirst*: η συνάρτηση αυτή υλοποιεί την διάσχιση BFS και παίρνει σαν ορίσματα τον γράφο,μια συνάρτηση εκτύπωσης την *PrintElement* και την αρχή που θα 
ξεκινήσουμε την διάσχιση του γράφου.Έχω πάρει την υλοποίηση της BFS από τις διαλέξεις του μαθήματος και την έχω τροποποιήσει κατάλληλα ώστε να ξεκινάει την διάσχιση 
απο το σημείο που ο χρήστης όρισε και διατρέχει όλες τις κορυφές.Για να πετύχω αυτό αρχικά έχω έναν βρόχο που ξεκινάει ν=0 κορυφή μέχρι την τελευταία ,όταν μπαίνει 
στον for βρόχο έχω φτιάξει μια if συνθήκη όπου έχω αρχικοποιήση στην αρχή της συνάρτησης μια μεταβλητή count ίση με μηδέν αν η count είναι μηδέν η συνθήκη αληθής και 
το ν ισούται με την κορυφή που ο χρήστης πέρασε σαν όρισμα στην συνάρτηση.Γίνεται η προσθήκη του στοιχείου στην ουρά και όταν είναι το αφαιρώ για να το εκτυπώσω με την 
βοήθεια την συνάρτησης *PrintElement*.Έπειτα επισκέφτομαι τους γείτονες της κορυφής.Όλη αυτή η διαδικασία μέχρι η ουρά να μην είναι γεμάτη.Μετά όταν τελειώσω την while 
έχω μια συνθήκη if όπου λέω ότι αν το v είναι η τελευταία κορυφή ,ο count ισούται με ένα και αν έχω επισκευτή την αρχική κορυφή (την κορυφή του χρήστη) τότε αυξάνω το 
count ώστε να μην ξαναμπεί σε αυτή την συνθήκη και θέτω το ν=-1 για να πάει ο for βρόχος από την αρχή και να εξεταστούν όλες οι κορυφές που δεν έχουν εξεταστεί.Στην 
main συνάρτηση έχω δώσει να είναι η κορυφή αφετηρίας το μηδέν.


6.Η *IsConnected*: η συνάρτηση αυτή όπυ επιστρέφει αν ο γράφος είναι συνεκτικός ή όχι.Πάλι είναι μια τροποποίηση του κώδικα των διαλέξεων,όπου το μόνο που έχω προσθέσει 
είναι μια μεταβλητή αρχικοποιημένη με το μηδέν πριν μπει στον βρόχο,την οποία την χρησιμοποιώ σαν μετρητή.Τον οποίο τον αυξάνω μετα την while όπου τελειώνει όταν 
αδειάσει η ουρά.Όταν εξέλθει από τον βρόχο while αυξάνεται ο μετρητής.Αν ο μετρητής είναι 1 τότε ο γράφος είναι συνεκτικός αλλιώς αν είναι παραπάνω από 1 όσο είναι η 
τιμή του τόσοι είναι και οι υπογράφοι του γράφου ,οι οποίοι δεν ενώνονται μεταξύ τους με ακμή έτσι έχει σαν αποτέλεσμα ο γράφος να είναι μη συνεκτικός.Τον μετρητή τον 
έχω βάλει στο συγκεκριμένο σημείο επειδή όταν η while τελειώνει και η for όχι σημαίνει ότι δεν έχουν διασχίσει όλες οι κορυφές του γράφου και αυτό γιατί δεν συνδέονται 
οι μη επισκεπτομενες κορυφές με ακμές με τις άλλες (τις επισκεπτόμενος κορυφές).Αυτό που επιστρέφουμε στον χρήστη είναι ο  counter με τον αριθμό των υπογράφων.


7.Η *ConnectedComponents* : υπολογίζει τις συνεκτικές συνιστώσες του γράφου.Πάλι κάνω χρήση του κώδικα BFS των διαλέξεων.Οι τροποποιήσεις που έχω κάνει είναι να φτιάξω 
έναν στατικό πίνακα (πλήθος κορυφών * πλήθος κορυφών) ,τον οποίο τον αρχικοποιώ με -1.Μέσα στην while όπου διασχίζω τους γείτονες κάθε κορυφής θέτω την θέση του πίνακα 
check ,check[v][w] ίσο με 1, ότι δηλαδή στον οριζόντιο άξονα ν (κορυφή ν) και κάθετο άξονα w (γείτονες) συνδέονται με ακμή ,η τιμή της θέσης χρησιμοποιείται σαν flag ,
αφού διατρέξω όλες τις κορυφές του γράφου.Ανακαλώ τον πίνακα check ώστε να σβήσω (θέτοντας -1) τις διπλές ακμές .(Αφού έχουν αποθηκευτεί η (x,y) και η αντίθετη της 
(y,x) εμείς θέλουμε την μια ακμή και όχι την “διδυμη” της.Επομένως κάθε φορά που βρίσκω θέση ίση με 1 αυξάνω μια μεταβλητή που την χρησιμοποιώ σαν μετρητή 
(εκε μετράω τις συνεκτικές συνιστώσες) και θέτω με -1 την αντίθετη της ώστε να μην αποθηκευτεί η ίδια ακμή δύο φορές.Αυτό που επιστρέφει η συνάρτηση είναι ο counter.


8.Η *ShortestPaths*: η συνάρτηση αυτή βρίσκει τα ελάχιστα μονοπάτια απο μια κορυφή αφετηρίας που δίνει ο χρήστης (εγώ έχω δώσει την 2 κορυφή) προς τις γειτονικές 
κορυφές.Η *ShortestPaths* καλεί τις συναρτήσεις IsConnected ώστε να επιστρέψει το πλήθος των υπογράφων.Αυτό που επιστρέφει το πλήθος το χρησιμοποιώ ώστε να φτιάξω έναν 
δισδιάστατο πίνακα ,όπου αν έχω δύο υπογράφους τότε ο πίνακας έχει 2 γραμμές.Σε αυτόν τον πίνακα αποθηκεύω τα στοιχεία του κάθε υπογράφου.Το γέμισμα του πίνακα γίνεται 
με την βοήθεια της συνάρτησης path_subs.
            
Στην *path_subs* στην αρχή αρχικοποιώ όλες τις θέσεις του πίνακα με -1.(Η υλοποίηση και αυτή είναι μια επέκταση του BFS).Η συνάντηση αυτή ,αυτό που κάνει είναι όταν   
επισκέπτεται στην αρχή κάποια κορυφή  την αποθηκεύει στον πίνακα visited και ταυτόχρονα την αποθηκεύει και στην 1η στήλη της τρέχουσα γραμμής (στον τρέχον υπογράφο ) , 
δηλαδή αποθηκεύει τον πατέρα.Επειτα καθώς διασχίζω τους γείτονες τους αποθηκεύω στην τρέχουσα γραμμή (εκεί ελέγχω ταυτόχρονα αν έχω αποθηκεύσει το στοιχείο ξανά 
ανατρέχοντας όλα τα στοιχεία του πίνακα,εχοντας την μεταβλητή οκ σαν flag ).

Αφού γεμίσω τον πίνακα μέσω της path_subs ελέγχω σε ποιά γραμμή βρίσκεται η κορυφή αφετηρίας δηλαδή σε ποιόν υπογράφο βρίσκεται.Επιπλέον δημιουργώ έναν πίνακα (paths) 
δομής ,όπου η δομή περιέχει δύο ακέραιες μεταβλητές για την αποθήκευση των συντεταγμένων των ακμών.Ο πίνακας αυτός θα έχει αποθηκευμένα τα μονοπάτια που θα βρώ για κάθε 
γειτονική κορυφή.Στην συνεχεια έχω ένα βρόχο for όπου θα ανατρέξει όλες τις κορυφές προορισμού του γράφου.Η πρώτη συνθήκη μέσα στον βρόχο είναι αν η κορυφή προορισμού 
ταυτίζεται με την κορυφή αφετηρίας ,τότε φτιάχνω σαν μονοπάτι μια ακμή την οποία την έχω αρχικοποιήσει με x=y=-1 και αυτό γιατί θέλω να λειτουργεί σαν flag και συνεχίζω 
στην επομένη κορυφή προορισμού.Έπειτα ελέγχω αν η τρέχουσα κορυφή προορισμού υπάρχει στον υπογράφο που βρίσκεται η κορυφή αφετηρίας αν δεν βρίσκεται τότε φτιάχνω σαν 
μονοπάτι μια ακμή την οποία την έχω αρχικοποιήσει με x=y=-2 (και αυτό πάλι θέλω να λειτουργεί σαν flag),και μετά πάω να βρώ το μονοπάτι της επόμενης κορυφής προορισμού 
(end).Εαν δεν ισχύουν οι δύο συνθήκες συνεχίζω και έχω έναν μονοδιάστατο πίνακα s που τον έχω αρχικοποιήσει με -1,θα αποθηκεύω στην θέση χ την τιμή όπου η τιμή θα είναι 
ο πρόγονος του χ, δηλαδή θα με βοηθήσει στο path reconstruction.Κάνω την ίδια διαδικασία BFS και όταν επισκέπτομαι ένα γείτονα τον αποθηκεύω στον s όταν τελειώσει ο 
βρόχος while (δηλαδή να αδειάσει η ουρά) αποθηκεύω την διαδρομή στον πίνακα paths.


9) H *printpaths* εκτυπώνει τον πίνακα paths που είναι αποθηκευμένα τα μονοπάτια.Εκτυπώνοντας το κατάλληλο μήνυμα όταν η κορυφή αφετηρίας ταυτίζεται με την κορυφή 
προορισμού ή η κορυφή προορισμού δεν συνδέεται με μονοπάτι με την κορυφή αφετηρίας ,αφού δεν υπάρχει ακμή να τις συνδέσει.


10) Τέλος για την λειτουργία της ουράς που χρησιμοποποιώ στην υλοποίηση της BFS έχω τις συναρτήσεις Empty όπου επιστρέφει αν ουρά είναι κενή, την Initialize όπου 
αρχικοποιώ την ουρά, την Remove όπου εξάγω ένα στοιχείο από την ουρά και τέλος την Insert όπου εισάγω στοιχείο στην ουρά.